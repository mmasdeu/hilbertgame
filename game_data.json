{"name": "The Hilbert game", "version": "1.1.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "The Hilbert game-1.1.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 4, "objects": [{"type": "tactic", "content": "3", "name": "refl", "sideBar": true}, {"type": "text", "content": "4"}, {"type": "hint", "content": "5", "title": "6"}, {"type": "lean", "content": "7", "hidden": true}, {"type": "lemma", "text": "8", "lean": "lemma refl_example (A : \u03a9) : A = A :=\n", "sideBar": false, "firstProofLineNumber": 43, "lastProofLineNumber": 44, "textBefore": "/- Tactic : refl\n\n## Summary\n\n`refl` is a tactic which proves goals of the form `X = X`.\n\n## Details\n\nThe `refl` tactic will close any goal of the form `A = B`\nwhere `A` and `B` are *exactly the same thing*.\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nA : Point\n\u22a2 A = A\n```\n\nthen\n\n`refl,`\n\nwill close the goal and solve the level. Don't forget the comma.\n\n-/\n\n/-\nWe will start by practising with the simplest tactic, namely *refl*. This just proves goals\nof the form $A = A$, no matter how complicated $A$ is. Let's see it in action!\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nJust delete `sorry` and type `refl,` (don't forget the comma!).\n-/\n\nvariables {\u03a9 : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A is a point, then A = A.\n-/\nlemma refl_example (A : \u03a9) : A = A :=\nbegin\n", "proof": "  refl,\n  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 2, "editorText": "sorry", "lineOffset": 42, "name": "refl_example", "statement": "(A : \u03a9) : A = A"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level01_refl.lean"}, {"name": "", "problemIndex": 4, "objects": [{"type": "tactic", "content": "9", "name": "rw", "sideBar": true}, {"type": "text", "content": "10"}, {"type": "hint", "content": "11", "title": "12"}, {"type": "lean", "content": "13", "hidden": true}, {"type": "lemma", "text": "14", "lean": "lemma example_rw (A B C: \u03a9) (h1 : A = B) (h2 : B = C) : A = C :=\n", "sideBar": false, "firstProofLineNumber": 90, "lastProofLineNumber": 92, "textBefore": "/- Tactic : rw\n\n## Summary\n\nIf `h` is a proof of `X = Y`, then `rw h,` will change\nall `X`s in the goal to `Y`s. \n\n**Variants:** `rw \u2190 h` changes\n`Y` to `X` and\n`rw h at h2` changes `X` to `Y` in hypothesis `h2` instead\nof the goal.\n\n## Details\n\nThe `rw` tactic is a way to do \"substituting in\". There\nare two distinct situations where use this tactics.\n\n1) If `h : A = B` is a hypothesis (i.e., a proof of `A = B`)\nin your local context (the box in the top right)\nand if your goal contains one or more `A`s, then `rw h`\nwill change them all to `B`'s. \n\n2) The `rw` tactic will also work with proofs of theorems\nwhich are equalities (look for them in the drop down\nmenu on the left, within Theorem Statements).\n\n**Important note:** if `h` is not a proof of the form `A = B`\nor `A \u2194 B` (for example if `h` is a function, an implication,\nor perhaps even a proposition itself rather than its proof),\nthen `rw` is not the tactic you want to use. For example,\n`rw (P = Q)` is never correct: `P = Q` is the true-false\nstatement itself, not the proof.\nIf `h : P = Q` is its proof, then `rw h` will work.\n\n**Pro tip 1:** If `h : A = B` and you want to change\n`B`s to `A`s instead, try `rw \u2190h` (get the arrow with `\\l`,\nnote that this is a small letter L, not a number 1).\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nA B C : Point\nh1 : A = B\nh2 : B = C\n\u22a2 A = C\n```\n\nthen\n\n`rw h1,`\n\nwill change the goal into `\u22a2 B = C`.\n\n### Example: \nYou can use `rw` to change a hypothesis as well. \nFor example, if your local context looks like this:\n```\nA B C : Point\nh1 : A = C\nh2 : A = B\n\u22a2 B = C\n```\nthen `rw h1 at h2` will turn `h2` into `h2 : C = B` (remember operator precedence).\n\n-/\n\n\n/-\nThe next tactic we will learn is `rw` (from rewrite). It rewrites equalities. That is,\nif we have a proof `h : A = B` and we want to prove `\u22a2 A = C`, then after `rw h` the goal\nwill become `\u22a2 B = C`.\n\nAfter many tactics (and `rw` is one of them) Lean tries to apply `refl`. This is why\nin the following proof you may get away with only two tactic applications.\n\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nDelete `sorry` and type `rw h,` (don't forget the comma!). Lean tries `refl` afterwards,\nso you will see that this suffices.\n-/\n\nvariables {\u03a9 : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A, B and C are points with A = B and B = C, then A = C.\n-/\nlemma example_rw (A B C: \u03a9) (h1 : A = B) (h2 : B = C) : A = C :=\nbegin\n", "proof": "  rw h1,\n  rw h2,\n  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 3, "editorText": "sorry", "lineOffset": 89, "name": "example_rw", "statement": "(A B C: \u03a9) (h1 : A = B) (h2 : B = C) : A = C"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level02_rw.lean"}, {"name": "", "problemIndex": 2, "objects": [{"type": "text", "content": "15"}, {"type": "lean", "content": "16", "hidden": true}, {"type": "lemma", "text": "17", "lean": "lemma example_exact (A B C: \u03a9) (h1 : B = A) (h2 : B = C) : A = C :=\n", "sideBar": false, "firstProofLineNumber": 15, "lastProofLineNumber": 18, "textBefore": "/-\nLet's practice a little bit more with the `rw` tactic. The hypotheses in this level are\na bit different than before, so you should use `rw \u2190` instead. You can\ntype the little arrow by typing \\l, and the system will change it automatically.\n-/\n\n\nvariables {\u03a9 : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A, B and C are points with B = C and B = C, then A = C.\n-/\nlemma example_exact (A B C: \u03a9) (h1 : B = A) (h2 : B = C) : A = C :=\nbegin\n", "proof": "  rw \u2190h1,\n  rw h2,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 4, "editorText": "sorry", "lineOffset": 14, "name": "example_exact", "statement": "(A B C: \u03a9) (h1 : B = A) (h2 : B = C) : A = C"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level03_rwbis.lean"}, {"name": "", "problemIndex": 4, "objects": [{"type": "tactic", "content": "18", "name": "exact", "sideBar": true}, {"type": "text", "content": "19"}, {"type": "hint", "content": "20", "title": "21"}, {"type": "lean", "content": "22", "hidden": true}, {"type": "lemma", "text": "23", "lean": "lemma example_exact (A B C: \u03a9) (h1 : A = B) (h2 : B = C) : A = C :=\n", "sideBar": false, "firstProofLineNumber": 49, "lastProofLineNumber": 52, "textBefore": "/- Tactic : exact\n\n## Summary \n\nIf the goal is `\u22a2 X` then `exact x` will close the goal if\nand only if `x` is a term of type `X`. \n\n## Details\n\nSay `P`, `Q` and `R` are types (i.e., what a mathematician\nmight think of as either sets or propositions),\nand the local context looks like this: \n\n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\n\nIf you can spot how to make a term of type `R`, then you\ncan just make it and say you're done using the `exact` tactic\ntogether with the formula you have spotted. For example the\nabove goal could be solved with\n\n`exact j(h(p)),`\n\nbecause `j(h(p))` is easily checked to be a term of type `R`\n(i.e., an element of the set `R`, or a proof of the proposition `R`).\n\n-/\n\n/-\nIn this level we learn the tactic `exact`, which solves a goal that is exactly one of the hypotheses.\nThe lemma is the same as in the previous level, but we will solve it in a different way.\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nBy doing a `rw` you will get the goal to look exactly like one of the hypotheses...\n-/\n\nvariables {\u03a9 : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A, B and C are points with A = B and B = C, then A = C.\n-/\nlemma example_exact (A B C: \u03a9) (h1 : A = B) (h2 : B = C) : A = C :=\nbegin\n", "proof": "  rw h1,\n  exact h2,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 4, "editorText": "sorry", "lineOffset": 48, "name": "example_exact", "statement": "(A B C: \u03a9) (h1 : A = B) (h2 : B = C) : A = C"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level04_exact.lean"}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "24", "hidden": true}, {"type": "lean", "content": "25", "hidden": true}, {"type": "axiom", "content": "26", "name": "", "sideBar": true}, {"type": "axiom", "content": "27", "name": "", "sideBar": true}, {"type": "text", "content": "28"}, {"type": "lean", "content": "29", "hidden": true}, {"type": "lemma", "text": "30", "lean": "lemma point_on_line {A B : \u03a9} {r : Line \u03a9} :\nB \u2208 line_through A B :=\n", "sideBar": false, "firstProofLineNumber": 24, "lastProofLineNumber": 26, "textBefore": "import tutorial_world.incidenceplane --hide\nopen IncidencePlane --hide\n\n/- Axiom :\nline_through_left : P \u2208 (line_through P Q)\n-/\n/- Axiom :\nline_through_right : Q \u2208 (line_through P Q)\n-/\n\n/-\nWe can apply a theorem that we have already proven by using `exact`\nand the appropriate hypotheses.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n\n/- Lemma :  no-side-bar\nA point lies in the line through it.\n-/\nlemma point_on_line {A B : \u03a9} {r : Line \u03a9} :\nB \u2208 line_through A B :=\nbegin\n", "proof": "  exact line_through_right A B,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n", "height": 3, "editorText": "sorry", "lineOffset": 23, "name": "point_on_line", "statement": "{A B : \u03a9} {r : Line \u03a9} :\nB \u2208 line_through A B"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level05_lemma_usage.lean"}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "31", "hidden": true}, {"type": "lean", "content": "32", "hidden": true}, {"type": "axiom", "content": "33", "name": "", "sideBar": true}, {"type": "tactic", "content": "34", "name": "intro", "sideBar": true}, {"type": "text", "content": "35"}, {"type": "lean", "content": "36", "hidden": true}, {"type": "lean", "content": "37", "hidden": true}, {"type": "lemma", "text": "38", "lean": "lemma equal_lines_of_contain_two_points :\nA \u2260 B \u2192 A \u2208 r \u2192  A \u2208 s \u2192 B \u2208 r \u2192 B \u2208 s \u2192 \tr = s :=\n", "sideBar": true, "firstProofLineNumber": 60, "lastProofLineNumber": 66, "textBefore": "import tutorial_world.incidenceplane --hide\nopen IncidencePlane --hide\n\n/- Axiom :\nincidence : P \u2260 Q \u2192 P \u2208 \u2113 \u2192 Q \u2208 \u2113 \u2192 \u2113 = line_through P Q\n-/\n\n/- Tactic : intro\n\n## Summary:\n\n`intro p` will turn a goal `\u22a2 P \u2192 Q` into a hypothesis `p : P`\nand goal `\u22a2 Q`. If `P` and `Q` are sets `intro p` means \"let $p$ be an arbitrary element of $P$\".\nIf `P` and `Q` are propositions then `intro p` says \"assume $P$ is true\". \n\n## Details\n\nIf your goal is a function or an implication `\u22a2 P \u2192 Q` then `intro`\nwill always make progress. `intro p` turns\n\n`\u22a2 P \u2192 Q`\n\ninto \n\n```\np : P\n\u22a2 Q\n```\n\nThe opposite tactic to intro is `revert`; given the situation\njust above, `revert p` turns the goal back into `\u22a2 P \u2192 Q`.\n\n**Variant:** Instead of calling `intro` multiple times, you can use\n`intros`. That is, `intros h\u2081 h\u2082` is equivalent to `intro h\u2081, intro h\u2082`.\n\n## Example\n\nIf your goal is an implication $P\\implies Q$ then Lean writes\nthis as `\u22a2 P \u2192 Q`, and `intro p,` can be thought of as meaning\n\"let $p$ be a proof of $P$\", or more informally \"let's assume that\n$P$ is true\". The goal changes to `\u22a2 Q` and the hypothesis `p : P`\nappears in the local context.\n\n-/\n\n/-\nThis level introduces the `intros` tactic. This allows you to introduce\na new hypothesis in the context. You can learn more about it in the side bar.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\nvariables {A B : \u03a9} {r s : Line \u03a9} -- hide\n\n/- Lemma :\nIf two lines contain two distinct points, then they are the same\n-/\nlemma equal_lines_of_contain_two_points :\nA \u2260 B \u2192 A \u2208 r \u2192  A \u2208 s \u2192 B \u2208 r \u2192 B \u2208 s \u2192 \tr = s :=\nbegin\n", "proof": "  intros hAB hAr hAs hBr hBs,\n  rw incidence hAB hAr hBr,\n  rw incidence hAB hAs hBs,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 7, "editorText": "sorry", "lineOffset": 59, "name": "equal_lines_of_contain_two_points", "statement": "A \u2260 B \u2192 A \u2208 r \u2192  A \u2208 s \u2192 B \u2208 r \u2192 B \u2208 s \u2192 \tr = s"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level06_intro.lean"}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "39", "hidden": true}, {"type": "lean", "content": "40", "hidden": true}, {"type": "tactic", "content": "41", "name": "split", "sideBar": true}, {"type": "text", "content": "42"}, {"type": "lean", "content": "43", "hidden": true}, {"type": "lemma", "text": "44", "lean": "lemma line_through_contains_points (P Q : \u03a9) : P \u2208 (line_through P Q) \u2227 Q \u2208 (line_through P Q)\n:=\n", "sideBar": false, "firstProofLineNumber": 63, "lastProofLineNumber": 65, "textBefore": "import tutorial_world.level06_intro --hide\nopen IncidencePlane --hide\n\n/- Tactic : split\n\n## Summary:\n\nIf the goal is `P \u2227 Q` or `P \u2194 Q` then `split` will break it into two goals.\n\n## Details\n\nIf `P Q : Prop` and the goal is `\u22a2 P \u2227 Q`, then `split` will change it into\ntwo goals, namely `\u22a2 P` and `\u22a2 Q`. \n\nIf `P Q : Prop` and the goal is `\u22a2 P \u2194 Q`, then `split` will change it into\ntwo goals, namely `\u22a2 P \u2192 Q` and `\u22a2 Q \u2192 P`.  \n\n## Example:\n\nIf your local context (the top right window) looks like this\n```\nX : Type\nA B : set X\nx : X\n\u22a2 x \u2208 A \u2194 x \u2208 B\n```\n\nthen after\n\n`split,`\n\nit will look like this:\n\n```\n2 goals\nX : Type\nA B : set X\nx : X\n\u22a2 x \u2208 A \u2192 x \u2208 B\n\n\nX : Type\nA B : set X\nx : X\n\u22a2 x \u2208 B \u2192 x \u2208 A\n```\n-/\n\n/-\nIn this level we will learn the `split` tactic. It breaks a goal `P \u2227 Q` into two goals (proving `P`, and then proving `Q`),\nand also breaks goals of the form `P \u2194 Q` into proving each of the implications separately.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n\n\n/- Lemma : no-side-bar\nIf two lines contain two distinct points, then they are the same\n-/\nlemma line_through_contains_points (P Q : \u03a9) : P \u2208 (line_through P Q) \u2227 Q \u2208 (line_through P Q)\n:=\nbegin\n", "proof": "  split,\n  exact line_through_left P Q,\n  exact line_through_right P Q,", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 3, "editorText": "sorry", "lineOffset": 62, "name": "line_through_contains_points", "statement": "(P Q : \u03a9) : P \u2208 (line_through P Q) \u2227 Q \u2208 (line_through P Q)"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level07_split.lean"}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "45", "hidden": true}, {"type": "lean", "content": "46", "hidden": true}, {"type": "lean", "content": "47", "hidden": true}, {"type": "tactic", "content": "48", "name": "use", "sideBar": true}, {"type": "text", "content": "49"}, {"type": "lean", "content": "50", "hidden": true}, {"type": "lemma", "text": "51", "lean": "lemma line_containing_point (P : \u03a9) : \u2203 \u2113 : Line \u03a9, P \u2208 \u2113 :=\n", "sideBar": false, "firstProofLineNumber": 26, "lastProofLineNumber": 29, "textBefore": "import tutorial_world.level07_split --hide\nopen IncidencePlane --hide\nopen set --hide\n\n/- Tactic : use\n\n## Summary\nThe tactic use specializes the goal with a particular case.\nFor example, if we want to prove the statement \"there exists a natural number which is odd\",\nwe will need to provide a concrete number like 3. \n-/\n\n/-\nSometimes we will need to prove that there exists an object satisfying certain properties.\nThe goal will then look like \u22a2 \u2203 x, P x. In this case, the `use` tactic is useful. If we know\nthat an object `a` satisfies the  property `P`, then `use a` will transform the goal into \u22a2 P a.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n\n/- Lemma : no-side-bar\nGiven a point, there is always a line containing it.\n-/\nlemma line_containing_point (P : \u03a9) : \u2203 \u2113 : Line \u03a9, P \u2208 \u2113 :=\nbegin\n", "proof": "  use line_through P P,\n  exact line_through_left P P,\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 4, "editorText": "sorry", "lineOffset": 25, "name": "line_containing_point", "statement": "(P : \u03a9) : \u2203 \u2113 : Line \u03a9, P \u2208 \u2113"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level08_use.lean"}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "52", "hidden": true}, {"type": "lean", "content": "53", "hidden": true}, {"type": "tactic", "content": "54", "name": "have", "sideBar": true}, {"type": "text", "content": "55"}, {"type": "lean", "content": "56", "hidden": true}, {"type": "lemma", "text": "57", "lean": "lemma equal_lines_example (B C : \u03a9) (h : B \u2260 C) (r s : Line \u03a9)\n(h1 :  B \u2208 r \u2227 C \u2208 r)\n(h2 : B \u2208 s \u2227 C \u2208 s)\n: r = s :=\n", "sideBar": false, "firstProofLineNumber": 69, "lastProofLineNumber": 78, "textBefore": "import tutorial_world.level08_use --hide\nopen IncidencePlane --hide\n/- Tactic : have\n\n## Summary\n`have h : P,` will create a new goal of creating a term of type `P`, and will add `h : P` to the hypotheses for the goal you were working on.\n\n## Details\nIf you want to name a term of some type (because you want it in your local context for some reason), and if you have the formula for the term, you can use have to give the term a name.\n\n## Example (have q := ... or have q : Q := ...)\nIf the local context contains\n\n```\nf : P \u2192 Q\np : P\n```\nthen the tactic `have q := f(p),` will add `q` to our local context, leaving it like this:\n\n```\nf : P \u2192 Q\np : P\nq : Q\n```\n\nIf you think about it, you don't ever really need `q`, because whenever you think you need it you coudl just use `f(p)` instead. But it's good that we can introduce convenient notation like this.\n\n## Example (have q : Q,)\nA variant of this tactic can be used where you just declare the type of the term you want to have, finish the tactic statement with a comma and no :=, and then Lean just adds it as a new goal. The number of goals goes up by one if you use `have` like this.\n\nFor example if the local context is\n\n```\nP Q R : Prop/Type,\nf : P \u2192 Q,\ng : Q \u2192 R,\np : P\n\u22a2 R\n```\nthen after `have q : Q,`, there will be the new goal\n\n```\nf : P \u2192 Q,\ng : Q \u2192 R,\np : P,\n\u22a2 Q\n```\nand your original goal will have `q : Q` added to the list of hypotheses.\n-/\n\n/-\nIn this level we introduce the new tactic `have`. It is used to add a new hypothesis\nto the context (of course, you will have to prove it!). This is sometimes useful to\nstructure our proofs. In this particular level, it is convenient to prove first that\n`r = line_through B C`, then that `s = line_through B C` and that allows us to\nfinish the prove very easily.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n\n/- Lemma : no-side-bar\nIf two lines share two distinct points then they are the same\n-/\nlemma equal_lines_example (B C : \u03a9) (h : B \u2260 C) (r s : Line \u03a9)\n(h1 :  B \u2208 r \u2227 C \u2208 r)\n(h2 : B \u2208 s \u2227 C \u2208 s)\n: r = s :=\nbegin\n", "proof": "  have hr : r = line_through B C,\n  {\n    exact incidence h h1.1 h1.2,\n  },\n  rw hr,\n  have hs : s = line_through B C,\n  {\n    exact incidence h h2.1 h2.2,\n  },\n  rw hs,", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 10, "editorText": "sorry", "lineOffset": 68, "name": "equal_lines_example", "statement": "(B C : \u03a9) (h : B \u2260 C) (r s : Line \u03a9)\n(h1 :  B \u2208 r \u2227 C \u2208 r)\n(h2 : B \u2208 s \u2227 C \u2208 s)\n: r = s"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level09_have.lean"}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "58", "hidden": true}, {"type": "lean", "content": "59", "hidden": true}, {"type": "tactic", "content": "60", "name": "cases", "sideBar": true}, {"type": "lean", "content": "61", "hidden": true}, {"type": "text", "content": "62"}, {"type": "lemma", "text": "63", "lean": "lemma line_through_from_and (P Q : \u03a9) (\u2113 : Line \u03a9) (h1 : P \u2260 Q)\n(h2 : P \u2208 \u2113 \u2227 Q \u2208 \u2113) : \u2113 = line_through P Q :=\n", "sideBar": false, "firstProofLineNumber": 71, "lastProofLineNumber": 75, "textBefore": "import tutorial_world.level09_have --hide\nopen set IncidencePlane --hide\n\n/- Tactic : cases\n\n## Summary:\n\n`cases` is a tactic which works on hypotheses.\nIf `h : P \u2227 Q` or `h : P \u2194 Q` is a hypothesis then `cases h with h1 h2` will remove `h`\nfrom the list of hypotheses and replace it with the \"ingredients\" of `h`,\ni.e. `h1 : P` and `h2 : Q`, or `h1 : P \u2192 Q` and `h2 : Q \u2192 P`. Also\nworks with `h : P \u2228 Q` and with `h : \u2203 x, P x`. \n\n## Details\n\nHow does one prove `P \u2227 Q`? The way to do it is to prove `P` and to\nprove `Q`. There are hence two ingredients which go into a proof of\n`P \u2227 Q`, and the `cases` tactic extracts them. \n\nMore precisely, if the local context contains\n```\nh : P \u2227 Q`\n```\n\nthen after the tactic `cases h with p q,` the local context will\nchange to\n```\np : P,\nq : Q\n```\nand `h` will disappear. \n\nSimilarly `h : P \u2194 Q` is proved by proving `P \u2192 Q` and `Q \u2192 P`,\nand `cases h with hpq hqp` will delete our assumption `h` and\nreplace it with\n```\nhpq : P \u2192 Q,\nhqp : Q \u2192 P\n```\n\nBe warned though -- `rw h` works with `h : P \u2194 Q` (`rw` works with\n`=` and `\u2194`), whereas you cannot rewrite with an implication.\n\n`cases` also works with hypotheses of the form `P \u2228 Q`. Here the situation\nis different however. \nTo prove `P \u2228 Q` you need to give either a proof of `P` *or* a proof\nof `Q`, so if `h : P \u2228 Q` then `cases h with p q` will change one goal\ninto two, one with `p : P` and the other with `q : Q`.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n\n/-\nThe next tactic we introduce is `cases`, and since it does many things\nwe will have a couple levels seeing when to apply it. This tactic works\nalways on hypotheses, and it transforms them in different ways. The first\ninstance that we learn arises when you have a hypothesis that says that `P`\nor `Q` holds. That is, you have `h : P \u2227 Q`. Then `cases h with h\u2081 h\u2082` will \nreplace `h` with two new hypotheses, namely `h\u2081 : P` and `h\u2082 : Q`.\n\nThis is done usually for aesthetic reasons, since `h.1` and `h.2` also serve\nas proofs of `P` and `Q`.\n-/\n\n/- Lemma : no-side-bar\nThe line \u2113 is the line through P and Q as long as P \u2260 Q and both P and Q are in \u2113\n-/\nlemma line_through_from_and (P Q : \u03a9) (\u2113 : Line \u03a9) (h1 : P \u2260 Q)\n(h2 : P \u2208 \u2113 \u2227 Q \u2208 \u2113) : \u2113 = line_through P Q :=\nbegin\n", "proof": "  cases h2 with hP hQ,\n  exact incidence h1 hP hQ,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 5, "editorText": "sorry", "lineOffset": 70, "name": "line_through_from_and", "statement": "(P Q : \u03a9) (\u2113 : Line \u03a9) (h1 : P \u2260 Q)\n(h2 : P \u2208 \u2113 \u2227 Q \u2208 \u2113) : \u2113 = line_through P Q"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level10_cases1_and.lean"}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "64", "hidden": true}, {"type": "lean", "content": "65", "hidden": true}, {"type": "lean", "content": "66", "hidden": true}, {"type": "text", "content": "67"}, {"type": "lemma", "text": "68", "lean": "lemma nonempty_example (P Q : \u03a9) (X : set \u03a9) (h : P \u2208 X \u2228 Q \u2208 X) : \u2203 R, R \u2208 X :=\n", "sideBar": false, "firstProofLineNumber": 19, "lastProofLineNumber": 31, "textBefore": "import tutorial_world.level10_cases1_and --hide\nopen set IncidencePlane --hide\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n\n/-\nSuppose now that your hypothesis says that `P`\n**or** `Q` holds. That is, you have `h : P \u2228 Q`. Then `cases h` will\ncreate two new goals, and in each of them it will\nreplace `h` with `h : P` in the first case, and with `h : Q` in the second.\n\n-/\n\n/- Lemma : no-side-bar\nIf X is any set in \u03a9 and either P or Q is in X, then X is not empty.\n-/\nlemma nonempty_example (P Q : \u03a9) (X : set \u03a9) (h : P \u2208 X \u2228 Q \u2208 X) : \u2203 R, R \u2208 X :=\nbegin\n", "proof": "  cases h,\n  {\n    use P,\n    exact h\n  },\n  {\n    use Q,\n    exact h\n  }\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 13, "editorText": "sorry", "lineOffset": 18, "name": "nonempty_example", "statement": "(P Q : \u03a9) (X : set \u03a9) (h : P \u2208 X \u2228 Q \u2208 X) : \u2203 R, R \u2208 X"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level11_cases2_or.lean"}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "69", "hidden": true}, {"type": "lean", "content": "70", "hidden": true}, {"type": "lean", "content": "71", "hidden": true}, {"type": "text", "content": "72"}, {"type": "lemma", "text": "73", "lean": "lemma exists_line_example (P Q R S : \u03a9) (h : Q \u2260 R) (h1 : \u2203 \u2113 : Line \u03a9, P \u2208 \u2113 \u2227 Q \u2208 \u2113 \u2227 R \u2208 \u2113)\n(h2 : \u2203 \u2113 : Line \u03a9, Q \u2208 \u2113 \u2227 R \u2208 \u2113 \u2227 S \u2208 \u2113) :\n\u2203 \u2113 : Line \u03a9, P \u2208 \u2113 \u2227 Q \u2208 \u2113 \u2227 R \u2208 \u2113 \u2227 S \u2208 \u2113 :=\n", "sideBar": false, "firstProofLineNumber": 22, "lastProofLineNumber": 43, "textBefore": "import tutorial_world.level11_cases2_or --hide\nopen set IncidencePlane --hide\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n\n/-\nSuppose now that your hypothesis says there is some element `x` satisfying a certain\nproperty `P`. That is, you have `h : \u2203 x, P x`. Then `cases h with x hx` will\nreplace `h` with `x : X` and `hx : P x`. That is, from the fact that you know that\nsome `x` exists, it will give you one such `x` with the property that it is supposed\nto satisfy.\n\n-/\n\n/- Lemma : no-side-bar\nA line through 4 points given lines through two subsets of three\n-/\nlemma exists_line_example (P Q R S : \u03a9) (h : Q \u2260 R) (h1 : \u2203 \u2113 : Line \u03a9, P \u2208 \u2113 \u2227 Q \u2208 \u2113 \u2227 R \u2208 \u2113)\n(h2 : \u2203 \u2113 : Line \u03a9, Q \u2208 \u2113 \u2227 R \u2208 \u2113 \u2227 S \u2208 \u2113) :\n\u2203 \u2113 : Line \u03a9, P \u2208 \u2113 \u2227 Q \u2208 \u2113 \u2227 R \u2208 \u2113 \u2227 S \u2208 \u2113 :=\nbegin\n", "proof": "  cases h1 with r hr,\n  cases h2 with s hs,\n  have H : r = s,\n  {\n    exact equal_lines_of_contain_two_points h hr.2.1 hs.1 hr.2.2 hs.2.1,\n  },\n  use r,\n  split,\n  exact hr.1,\n  split,\n  exact hr.2.1,\n  split,\n  exact hr.2.2,\n  rw H,\n  exact hs.2.2,\n  \n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 22, "editorText": "sorry", "lineOffset": 21, "name": "exists_line_example", "statement": "(P Q R S : \u03a9) (h : Q \u2260 R) (h1 : \u2203 \u2113 : Line \u03a9, P \u2208 \u2113 \u2227 Q \u2208 \u2113 \u2227 R \u2208 \u2113)\n(h2 : \u2203 \u2113 : Line \u03a9, Q \u2208 \u2113 \u2227 R \u2208 \u2113 \u2227 S \u2208 \u2113) :\n\u2203 \u2113 : Line \u03a9, P \u2208 \u2113 \u2227 Q \u2208 \u2113 \u2227 R \u2208 \u2113 \u2227 S \u2208 \u2113"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level12_cases3_exists.lean"}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "74", "hidden": true}, {"type": "lean", "content": "75", "hidden": true}, {"type": "lean", "content": "76", "hidden": true}, {"type": "tactic", "content": "77", "name": "left and right", "sideBar": true}, {"type": "text", "content": "78"}, {"type": "lean", "content": "79", "hidden": true}, {"type": "lemma", "text": "80", "lean": "lemma left_right_example (A B C : \u03a9) (h : C \u2208 line_through A B) :\nA = C \u2228 collinear ({A, B, C} : set \u03a9) :=\n", "sideBar": false, "firstProofLineNumber": 32, "lastProofLineNumber": 54, "textBefore": "import tutorial_world.level12_cases3_exists --hide\nopen IncidencePlane --hide\nopen set --hide\n\n/- Tactic : left and right\n## Summary\n`left` and `right` work on the goal, and they change\n`\u22a2 P \u2228 Q` to `\u22a2 P` and `\u22a2 Q` respectively.\n## Details\nThe tactics `left` and `right` work on a goal which is a type with\ntwo constructors, the classic example being `P \u2228 Q`. \nTo prove `P \u2228 Q` it suffices to either prove `P` or prove `Q`,\nand once you know which one you are going for you can change\nthe goal with `left` or `right` to the appropriate choice.\n-/\n\n/-\nWe have seen how to prove a goal of the form `P \u2227 Q`, now you will learn how to prove\na goal of the form `P \u2228 Q`, which means that either `P` holds or `Q` holds.\nIn this case, you will have to decide whether you can prove `P` or `Q`. The `left` and `right`\ntactics will allow you to change the goal to \u22a2 P or \u22a2 Q accordingly.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] -- hide\n\n/- Lemma : no-side-bar\nExample of the usage of left and right\n-/\nlemma left_right_example (A B C : \u03a9) (h : C \u2208 line_through A B) :\nA = C \u2228 collinear ({A, B, C} : set \u03a9) :=\nbegin\n", "proof": "  right,\n  use line_through A B,\n  intros P hP,\n  cases hP,\n  {\n    rw hP,\n    exact line_through_left A B\n  },\n  cases hP,\n  {\n    rw hP,\n    exact line_through_right A B,\n  },\n  {\n    cases hP,\n    exact h,\n  }\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 23, "editorText": "sorry", "lineOffset": 31, "name": "left_right_example", "statement": "(A B C : \u03a9) (h : C \u2208 line_through A B) :\nA = C \u2228 collinear ({A, B, C} : set \u03a9)"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level13_leftright.lean"}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "81", "hidden": true}, {"type": "lean", "content": "82", "hidden": true}, {"type": "tactic", "content": "83", "name": "apply", "sideBar": true}, {"type": "text", "content": "84"}, {"type": "lean", "content": "85", "hidden": true}, {"type": "lean", "content": "86", "hidden": true}, {"type": "lemma", "text": "87", "lean": "lemma line_through_symmetrical (h : P \u2260 Q) : line_through Q P = line_through P Q :=\n", "sideBar": true, "firstProofLineNumber": 39, "lastProofLineNumber": 52, "textBefore": "import tutorial_world.level13_leftright --hide\nopen IncidencePlane --hide\n/- Tactic : apply\n\n## Summary\n\nIf `h : P \u2192 Q` is a hypothesis, and the goal is `\u22a2 Q` then\n`apply h` changes the goal to `\u22a2 P`. \n\n## Details\n\nIf you have a function `h : P \u2192 Q` and your goal is `\u22a2 Q`\nthen `apply h` changes the goal to `\u22a2 P`. The logic is\nsimple: if you are trying to create a term of type `Q`,\nbut `h` is a function which turns terms of type `P` into\nterms of type `Q`, then it will suffice to construct a\nterm of type `P`. A mathematician might say: \"we need\nto construct an element of $Q$, but we have a function $h:P\\to Q$\nso it suffices to construct an element of $P$\". Or alternatively\n\"we need to prove $Q$, but we have a proof $h$ that $P\\implies Q$\nso it suffices to prove $P$\".\n\n-/\n\n/-\nIn this level we introduce the new tactic `apply`. Suppose that you have a theorem `h`\nthat states exactly that your goal is true, provided that some hypotheses are satisfied. Then\n`apply h` will change your goal into proving your new hypotheses.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] -- hide\nvariables {P Q : \u03a9} -- hide\n\n/- Lemma :\nThe line through two points is a symmetrical concept\n-/\nlemma line_through_symmetrical (h : P \u2260 Q) : line_through Q P = line_through P Q :=\nbegin\n", "proof": "  apply incidence,\n  {\n    exact h,\n  },\n  {\n    exact line_through_right Q P,\n  },\n  {\n    exact line_through_left Q P,\n  }\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 14, "editorText": "sorry", "lineOffset": 38, "name": "line_through_symmetrical", "statement": "(h : P \u2260 Q) : line_through Q P = line_through P Q"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level14_apply.lean"}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "88", "hidden": true}, {"type": "lean", "content": "89", "hidden": true}, {"type": "tactic", "content": "90", "name": "simp", "sideBar": true}, {"type": "text", "content": "91"}, {"type": "lean", "content": "92", "hidden": true}, {"type": "lemma", "text": "93", "lean": "lemma simp_example (P : \u03a9) (S : Segment \u03a9) (h : S.A * P * S.B) : P \u2208 S :=\n", "sideBar": false, "firstProofLineNumber": 35, "lastProofLineNumber": 42, "textBefore": "import tutorial_world.level14_apply --hide\nopen IncidencePlane --hide\n\n/- Tactic : simp\n\n## Summary\nThe `simp` tactic is a high-level tactic which tries to prove equalities using facts in its database.\n\n## Details\nThe `simp` tactic does basic automation. It uses lemmas already proved that have been tagged\nwith a special label, to simplify either a goal or a hypothesis.\n\n## Example:\nFor `S` a segment, we have a lemma\n`mem_pts : P \u2208 S \u2194 P = S.A \u2228 P = S.B \u2228 (S.A * P * S.B)`, and it is tagged as a simp lemma\nin this game. This means that the `simp` tactic will replace occurrences of `P \u2208 S` with\nthe right-hand side, which is more concrete.\n-/\n\n/-\nIn this level we introduce a high level tactic called `simp`. This simplifies statements\nusing (some) lemmas already in our database. As a simple example, for `S` a segment we have a lemma\n`mem_pts : P \u2208 S \u2194 P = S.A \u2228 P = S.B \u2228 (S.A * P * S.B)`, and it is tagged as a simp lemma\nin this game. This means that the `simp` tactic will replace occurrences of `P \u2208 S` with\nthe right-hand side, which is more concrete. Try it below.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n\n/- Lemma : no-side-bar\nA point in between the endpoints of a segment is in the segment.\n-/\nlemma simp_example (P : \u03a9) (S : Segment \u03a9) (h : S.A * P * S.B) : P \u2208 S :=\nbegin\n", "proof": "  simp,\n  right,\n  right,\n  exact h,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 8, "editorText": "sorry", "lineOffset": 34, "name": "simp_example", "statement": "(P : \u03a9) (S : Segment \u03a9) (h : S.A * P * S.B) : P \u2208 S"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level15_simp.lean"}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "94", "hidden": true}, {"type": "lean", "content": "95", "hidden": true}, {"type": "tactic", "content": "96", "name": "exfalso", "sideBar": true}, {"type": "text", "content": "97"}, {"type": "hint", "content": "98", "title": "99"}, {"type": "lean", "content": "100", "hidden": true}, {"type": "lemma", "text": "101", "lean": "lemma two_plus_two_equals_five (P Q : \u03a9) (h: P \u2209 line_through P Q) : 2 + 2 = 5:=\n", "sideBar": false, "firstProofLineNumber": 39, "lastProofLineNumber": 47, "textBefore": "import tutorial_world.level15_simp -- hide\nopen IncidencePlane -- hide\n\n/- Tactic : exfalso\n\n## Summary\n\nChanges the goal to `\u22a2 false`.\n\n## Details\n\nThis may seem hard to prove,\nbut it is useful when we have a contradiction in the hypotheses.\n\nFor example, if we have `h : \u00ac P` as a hypothesis and we apply `exfalso`\nwe can then `apply h` to transform the goal into `\u22a2 P`.\n-/\n\n\n/-\nIn this level we introduce the new tactic `exfalso`. Look at what it does, it is a bit\nstrange at first. We will also need one of the axioms for our plane, the one that says that\nthe line through two points contains each of them. You can see the statement of this theorem\non the left sidebar.\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nIn Lean, the  negation `\u00ac P` of a statement is a shorthand for `P \u2192 false`. Therefore\nstart with `exfalso`, and remember that negation is the same as `\u2192 false`.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n\n/- Lemma : no-side-bar\nProve that 2+2 is 5, using a false hypothesis.\n-/\nlemma two_plus_two_equals_five (P Q : \u03a9) (h: P \u2209 line_through P Q) : 2 + 2 = 5:=\nbegin\n", "proof": "  exfalso,\n  apply h,\n  exact line_through_left P Q,\n\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend ", "height": 9, "editorText": "sorry", "lineOffset": 38, "name": "two_plus_two_equals_five", "statement": "(P Q : \u03a9) (h: P \u2209 line_through P Q) : 2 + 2 = 5"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level16_exfalso.lean"}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "102", "hidden": true}, {"type": "lean", "content": "103", "hidden": true}, {"type": "tactic", "content": "104", "name": "by_cases", "sideBar": true}, {"type": "text", "content": "105"}, {"type": "lean", "content": "106", "hidden": true}, {"type": "lemma", "text": "107", "lean": "lemma point_in_line_or_not {A : \u03a9}\t{r : Line \u03a9} : A \u2208 r \u2228 A \u2209 r :=\n", "sideBar": false, "firstProofLineNumber": 34, "lastProofLineNumber": 49, "textBefore": "import tutorial_world.level16_exfalso --hide\nopen IncidencePlane --hide\n\n/- Tactic : by_cases\n\n## Summary\n\nGenerates two goals corresponding to a given statement being\ntrue or false\n\n## Details\n\nSuppose that we want to prove a statement `P x`, where `x`\nis some number. We may know how to prove it when `x \u2264 5`\nand also when `x > 5`, but using a different method.\nIn this situation, using `by_cases h : x \u2264 5,` will produce\ntwo new goals, the first one with `h : x \u2264 5` in the context\nand the second one with `h : \u00ac x \u2264 5`.\n-/\n\n/-\nSometimes we need to split a proof into different cases,\nbecause the arguments depend on some condition. The `by_cases`\ntactic does precisely this.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n\n/- Lemma : no-side-bar\nEither a point is in a line or it is not.\n-/\nlemma point_in_line_or_not {A : \u03a9}\t{r : Line \u03a9} : A \u2208 r \u2228 A \u2209 r :=\nbegin\n", "proof": "  by_cases h : A \u2208 r,\n  { \n    left,\n    exact h,\n  },\n  { \n    right,\n    exact h,\n  }\n\n\n  \n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 16, "editorText": "sorry", "lineOffset": 33, "name": "point_in_line_or_not", "statement": "{A : \u03a9}\t{r : Line \u03a9} : A \u2208 r \u2228 A \u2209 r"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level17_by_cases.lean"}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "108", "hidden": true}, {"type": "lean", "content": "109", "hidden": true}, {"type": "text", "content": "110"}, {"type": "lean", "content": "111", "hidden": true}, {"type": "lemma", "text": "112", "lean": "@[simp] lemma one_point_segment (A B : \u03a9) : B \u2208 A\u2b1dA \u2194 B = A :=\n", "sideBar": true, "firstProofLineNumber": 15, "lastProofLineNumber": 47, "textBefore": "import tutorial_world.level17_by_cases --hide\nopen set IncidencePlane --hide\n\n/-\nThis is an extra level you can use for practice.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n\n/- Lemma :\nThe only point on the segment A\u2b1dA is A itself.\n-/\n@[simp] lemma one_point_segment (A B : \u03a9) : B \u2208 A\u2b1dA \u2194 B = A :=\nbegin\n", "proof": "  split,\n  {\n    intro hx,\n    cases hx,\n    {\n      exact hx,\n    },\n    {\n      cases hx,\n      {\n        exact hx,\n      },\n      {\n        exfalso,\n        apply (different_of_between hx).2.1,\n        refl,\n      }\n    }\n  },\n  {\n    intro h,\n    rw h,\n    left,\n    refl,\n  },\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 33, "editorText": "sorry", "lineOffset": 14, "name": "lemma", "statement": "one_point_segment (A B : \u03a9) : B \u2208 A\u2b1dA \u2194 B = A"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/tutorial_world/level18_practice.lean"}]}, {"name": "113", "levels": [{"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "114", "hidden": true}, {"type": "lean", "content": "115", "hidden": true}, {"type": "axiom", "content": "116", "name": "", "sideBar": true}, {"type": "text", "content": "117"}, {"type": "hint", "content": "118", "title": "119"}, {"type": "lean", "content": "120", "hidden": true}, {"type": "lemma", "text": "121", "lean": "lemma exists_point_not_in_line (\u2113 : Line \u03a9) : \u2203 (P : \u03a9), P \u2209 \u2113 :=\n", "sideBar": true, "firstProofLineNumber": 30, "lastProofLineNumber": 57, "textBefore": "import tutorial_world.level18_practice --hide\nopen IncidencePlane --hide\n\n/- Axiom :\nexistence : \u2203 P Q R : \u03a9, P \u2260 Q \u2227 P \u2260 R \u2227 Q \u2260 R \u2227 R \u2209 (line_through P Q)\n-/\n\n/-\nNow that we have introduced the basic Lean tactics, \nlet's move on to proving our first theorems.\n\nThe goal of this world is to prove the existence of\ntriangles, but we will start showing that there is no line\nthat covers the whole plane. That is, every line misses\nat least one point.\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nThis is really a proof `by_cases`, and you will need to come up\nwith some candidate points...\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n\n/- Lemma :\nEvery line misses at least one point.\n-/\nlemma exists_point_not_in_line (\u2113 : Line \u03a9) : \u2203 (P : \u03a9), P \u2209 \u2113 :=\nbegin\n", "proof": "  rcases existence \u03a9 with \u27e8A, B, C, \u27e8hAB, hAC, hBC, h\u27e9\u27e9,\n  by_cases hA : A \u2208 \u2113,\n  {\n    by_cases hB : B \u2208 \u2113,\n    {\n      use C,\n      have ltA := line_through_left A B,\n      have ltB := line_through_right A B,\n      rw (incidence hAB hA hB),\n      exact h,\n    },\n    {\n      use B,\n    }\n  },\n  {\n    use A,\n  }\n\n\n\n\n\n\n\n\n  \n  ", "proof_hint": "sorry", "textAfter": "\nend", "height": 28, "editorText": "sorry", "lineOffset": 29, "name": "exists_point_not_in_line", "statement": "(\u2113 : Line \u03a9) : \u2203 (P : \u03a9), P \u2209 \u2113"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/incidence_world/level01.lean"}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "122", "hidden": true}, {"type": "lean", "content": "123", "hidden": true}, {"type": "text", "content": "124"}, {"type": "hint", "content": "125", "title": "126"}, {"type": "lean", "content": "127", "hidden": true}, {"type": "lean", "content": "128", "hidden": true}, {"type": "lemma", "text": "129", "lean": "lemma point_in_line_not_point (hP : P \u2208 r) (hQ : Q \u2209 r): P \u2260 Q :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 31, "textBefore": "import incidence_world.level01 --hide\nopen IncidencePlane --hide\n\n/-\nThe next lemma is not hard to prove, but it will be useful\nin the coming levels.\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nRemember that `\u00ac P` is the same as `P \u2192 false`, so `intro` may\nget you going.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\nvariables  {P Q: \u03a9} {r : Line \u03a9}  -- hide\n\n/- Lemma :\nIf a point P is in a line and a point Q is not, then they are different.\n-/\nlemma point_in_line_not_point (hP : P \u2208 r) (hQ : Q \u2209 r): P \u2260 Q :=\nbegin\n", "proof": "  intro H,\n  rw H at hP,\n  exact hQ hP,\n  \n\n\n  \n  \n  \n  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 10, "editorText": "sorry", "lineOffset": 21, "name": "point_in_line_not_point", "statement": "(hP : P \u2208 r) (hQ : Q \u2209 r): P \u2260 Q"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/incidence_world/level02.lean"}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "130", "hidden": true}, {"type": "lean", "content": "131", "hidden": true}, {"type": "text", "content": "132"}, {"type": "lean", "content": "133", "hidden": true}, {"type": "lemma", "text": "134", "lean": "lemma point_existence_postulate (P : \u03a9) : \u2203 (Q R : \u03a9), P \u2260 Q \u2227 P \u2260 R \u2227 Q \u2260 R \u2227 \nR \u2209 (line_through P Q) :=\n", "sideBar": true, "firstProofLineNumber": 20, "lastProofLineNumber": 50, "textBefore": "import incidence_world.level02--hide\nopen IncidencePlane --hide\n\n/-\nUsing the lemma `point_in_line_not_point` that you proved in the previous\nlevel, we can prove a stronger version of the existence axiom. Remember that\nthis axiom says that there are three distinct non-collinear points. The\nresult in this level says that if we fix one point P, then we can find\ntwo other distinct points such that the three of them are non-collinear.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n\n/- Lemma :\nGiven a point P, there exist two points Q and R, such that the three points are not collinear.\n-/\nlemma point_existence_postulate (P : \u03a9) : \u2203 (Q R : \u03a9), P \u2260 Q \u2227 P \u2260 R \u2227 Q \u2260 R \u2227 \nR \u2209 (line_through P Q) :=\nbegin\n", "proof": "  rcases existence \u03a9 with \u27e8A, B, C, \u27e8hAB, hAC, hBC, h\u27e9\u27e9,\n  by_cases hA : P = A,\n  {\n    rw hA,\n    use B, use C,\n    exact \u27e8hAB, hAC, hBC, h\u27e9,\n  },\n  {\n    have htmp := exists_point_not_in_line (line_through' P A),\n    cases htmp with D hD,\n    use A, use D,\n    have hPD := point_in_line_not_point (line_through_left P A) hD,\n    have hAD := point_in_line_not_point (line_through_right P A) hD,\n    exact \u27e8hA, hPD, hAD, hD\u27e9,\n  }\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 31, "editorText": "sorry", "lineOffset": 19, "name": "point_existence_postulate", "statement": "(P : \u03a9) : \u2203 (Q R : \u03a9), P \u2260 Q \u2227 P \u2260 R \u2227 Q \u2260 R \u2227 \nR \u2209 (line_through P Q)"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/incidence_world/level03.lean"}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "135", "hidden": true}, {"type": "lean", "content": "136", "hidden": true}, {"type": "text", "content": "137"}, {"type": "lean", "content": "138", "hidden": true}, {"type": "lean", "content": "139", "hidden": true}, {"type": "lemma", "text": "140", "lean": "lemma ne_of_not_share_point  (hPr : P \u2208 r)\n(hPs : P \u2209 s): r \u2260 s:=\n", "sideBar": true, "firstProofLineNumber": 19, "lastProofLineNumber": 27, "textBefore": "import incidence_world.level03 --hide\nopen IncidencePlane --hide\n\n/-\nRemember that a couple of levels ago we proved that a line could help\nus deciding that two points were different. Now we will see that\na point can help us deciding that two lines are different.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\nvariables {P : \u03a9} {r s : Line \u03a9} --hide\n\n/- Lemma :\nIf two lines `r` and `s` do not share a point, then they are not equal.\n-/\nlemma ne_of_not_share_point  (hPr : P \u2208 r)\n(hPs : P \u2209 s): r \u2260 s:=\nbegin\n", "proof": "  intro H,\n  rw H at hPr,\n  exact hPs hPr,\n  \n  \n  \n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 18, "name": "ne_of_not_share_point", "statement": "(hPr : P \u2208 r)\n(hPs : P \u2209 s): r \u2260 s"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/incidence_world/level04.lean"}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "141", "hidden": true}, {"type": "lean", "content": "142", "hidden": true}, {"type": "text", "content": "143"}, {"type": "lean", "content": "144", "hidden": true}, {"type": "lemma", "text": "145", "lean": "lemma point_exists_two_lines (P : \u03a9) : \u2203 (r s: Line \u03a9), P \u2208 s \u2227 P \u2208 r \u2227 s \u2260 r :=\n", "sideBar": true, "firstProofLineNumber": 17, "lastProofLineNumber": 46, "textBefore": "import incidence_world.level04 --hide\nopen IncidencePlane --hide\n\n/-\nUsing the lemma we have just proved, we can now prove that\na single point never determines a line. That is, that there are\nalways at least two lines passing through any given point.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n\n/- Lemma :\nThere are at least two different lines passing through a given point.\n-/\nlemma point_exists_two_lines (P : \u03a9) : \u2203 (r s: Line \u03a9), P \u2208 s \u2227 P \u2208 r \u2227 s \u2260 r :=\nbegin\n", "proof": "  rcases (point_existence_postulate P) with \u27e8Q, R, \u27e8hPQ, hPR, hQR,H\u27e9\u27e9,\n  use line_through P Q,\n  use line_through P R,\n  split,\n  {\n    exact line_through_left P R,\n  },\n  split,\n  {\n    exact line_through_left P Q,\n  },\n  {\n    exact ne_of_not_share_point (line_through_right P R) H,\n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 30, "editorText": "sorry", "lineOffset": 16, "name": "point_exists_two_lines", "statement": "(P : \u03a9) : \u2203 (r s: Line \u03a9), P \u2208 s \u2227 P \u2208 r \u2227 s \u2260 r"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/incidence_world/level05.lean"}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "146", "hidden": true}, {"type": "lean", "content": "147", "hidden": true}, {"type": "text", "content": "148"}, {"type": "lean", "content": "149", "hidden": true}, {"type": "lemma", "text": "150", "lean": "lemma three_distinct_lines : \u2203 (r s t: Line \u03a9), (\u2200 (P : \u03a9),\n\u00ac(P \u2208 r \u2227 P \u2208 s \u2227 P \u2208 t)) :=\n", "sideBar": true, "firstProofLineNumber": 17, "lastProofLineNumber": 69, "textBefore": "import incidence_world.level05 --hide\nopen IncidencePlane --hide\n\n/-\nWe end this world by proving the existence of triangles\nusing only incidence axioms.\n-/\n\nvariables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n\n/- Lemma :\nThere exist three lines that do not have a point in common.\n-/\nlemma three_distinct_lines : \u2203 (r s t: Line \u03a9), (\u2200 (P : \u03a9),\n\u00ac(P \u2208 r \u2227 P \u2208 s \u2227 P \u2208 t)) :=\nbegin\n", "proof": "  rcases existence \u03a9 with \u27e8A, B, C, \u27e8hAB, hAC, hBC, h\u27e9\u27e9,\n  use line_through A B,\n  use line_through A C,\n  use line_through B C,\n  intros P H,\n  have h1 : line_through A C \u2260 line_through A B, \n  {\n    exact ne_of_not_share_point (line_through_right A C) h,\n  },\n  by_cases hPA : P = A,\n  {\n    have hAlBC : A \u2208 line_through B C,\n    {\n      rw \u2190 hPA,\n      exact H.2.2,\n    },\n    have H1 : line_through A C = line_through B C,\n    {\n      exact equal_lines_of_contain_two_points hAC (line_through_left A C) hAlBC (line_through_right A C) (line_through_right B C),\n    },\n    have H2 : line_through A C = line_through A B, \n    {\n      rw H1,\n      exact equal_lines_of_contain_two_points hAB hAlBC (line_through_left A B) (line_through_left B C) (line_through_right A B),\n    },\n    exact h1 H2,\n  },\n  {\n    have h2 : line_through A C = line_through A B, \n    {\n      exact equal_lines_of_contain_two_points hPA H.2.1 H.1 (line_through_left A C) (line_through_left A B),\n    },\n    exact h1 h2,\n  }\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  ", "proof_hint": "sorry", "textAfter": "\nend", "height": 53, "editorText": "sorry", "lineOffset": 16, "name": "three_distinct_lines", "statement": "\u2203 (r s t: Line \u03a9), (\u2200 (P : \u03a9),\n\u00ac(P \u2208 r \u2227 P \u2208 s \u2227 P \u2208 t))"}], "url": "https://raw.githubusercontent.com/mmasdeu/hilbertgame/main/src/incidence_world/level06.lean"}], "parents": [0]}], "texts": [["The Hilbert game", "# The Hilbert Game, version 1.0.0.\n\n## BIYSC 2022\n\nLearn Lean with the Hilbert plane!\n\n# What is this game?\n\nIn this game, you will learn the basics of Lean using as examples some\nfacts about geometry. Travel through different worlds solving challenges.\n\nHave fun!\n\n# Credits\n\nThe BIYSC team on \"Can computers do math?\" at UAB.\n\nSome of the tactic descriptions are taken/adapted from the original Natural Number Game (https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/).\n\nLean is a computer theorem prover being developed at Microsoft Research.\n\n", "Tutorial World", "\n## Summary\n\n`refl` is a tactic which proves goals of the form `X = X`.\n\n## Details\n\nThe `refl` tactic will close any goal of the form `A = B`\nwhere `A` and `B` are *exactly the same thing*.\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nA : Point\n\u22a2 A = A\n```\n\nthen\n\n`refl,`\n\nwill close the goal and solve the level. Don't forget the comma.\n\n", "We will start by practising with the simplest tactic, namely *refl*. This just proves goals\nof the form $A = A$, no matter how complicated $A$ is. Let's see it in action!\n", "Just delete `sorry` and type `refl,` (don't forget the comma!).\n", "Click here for a hint, in case you get stuck.", "variables {\u03a9 : Type} -- hide\n", "If A is a point, then A = A.\n", "\n## Summary\n\nIf `h` is a proof of `X = Y`, then `rw h,` will change\nall `X`s in the goal to `Y`s. \n\n**Variants:** `rw \u2190 h` changes\n`Y` to `X` and\n`rw h at h2` changes `X` to `Y` in hypothesis `h2` instead\nof the goal.\n\n## Details\n\nThe `rw` tactic is a way to do \"substituting in\". There\nare two distinct situations where use this tactics.\n\n1) If `h : A = B` is a hypothesis (i.e., a proof of `A = B`)\nin your local context (the box in the top right)\nand if your goal contains one or more `A`s, then `rw h`\nwill change them all to `B`'s. \n\n2) The `rw` tactic will also work with proofs of theorems\nwhich are equalities (look for them in the drop down\nmenu on the left, within Theorem Statements).\n\n**Important note:** if `h` is not a proof of the form `A = B`\nor `A \u2194 B` (for example if `h` is a function, an implication,\nor perhaps even a proposition itself rather than its proof),\nthen `rw` is not the tactic you want to use. For example,\n`rw (P = Q)` is never correct: `P = Q` is the true-false\nstatement itself, not the proof.\nIf `h : P = Q` is its proof, then `rw h` will work.\n\n**Pro tip 1:** If `h : A = B` and you want to change\n`B`s to `A`s instead, try `rw \u2190h` (get the arrow with `\\l`,\nnote that this is a small letter L, not a number 1).\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nA B C : Point\nh1 : A = B\nh2 : B = C\n\u22a2 A = C\n```\n\nthen\n\n`rw h1,`\n\nwill change the goal into `\u22a2 B = C`.\n\n### Example: \nYou can use `rw` to change a hypothesis as well. \nFor example, if your local context looks like this:\n```\nA B C : Point\nh1 : A = C\nh2 : A = B\n\u22a2 B = C\n```\nthen `rw h1 at h2` will turn `h2` into `h2 : C = B` (remember operator precedence).\n\n", "The next tactic we will learn is `rw` (from rewrite). It rewrites equalities. That is,\nif we have a proof `h : A = B` and we want to prove `\u22a2 A = C`, then after `rw h` the goal\nwill become `\u22a2 B = C`.\n\nAfter many tactics (and `rw` is one of them) Lean tries to apply `refl`. This is why\nin the following proof you may get away with only two tactic applications.\n\n", "Delete `sorry` and type `rw h,` (don't forget the comma!). Lean tries `refl` afterwards,\nso you will see that this suffices.\n", "Click here for a hint, in case you get stuck.", "variables {\u03a9 : Type} -- hide\n", "If A, B and C are points with A = B and B = C, then A = C.\n", "Let's practice a little bit more with the `rw` tactic. The hypotheses in this level are\na bit different than before, so you should use `rw \u2190` instead. You can\ntype the little arrow by typing \\l, and the system will change it automatically.\n", "variables {\u03a9 : Type} -- hide\n", "If A, B and C are points with B = C and B = C, then A = C.\n", "\n## Summary \n\nIf the goal is `\u22a2 X` then `exact x` will close the goal if\nand only if `x` is a term of type `X`. \n\n## Details\n\nSay `P`, `Q` and `R` are types (i.e., what a mathematician\nmight think of as either sets or propositions),\nand the local context looks like this: \n\n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\n\nIf you can spot how to make a term of type `R`, then you\ncan just make it and say you're done using the `exact` tactic\ntogether with the formula you have spotted. For example the\nabove goal could be solved with\n\n`exact j(h(p)),`\n\nbecause `j(h(p))` is easily checked to be a term of type `R`\n(i.e., an element of the set `R`, or a proof of the proposition `R`).\n\n", "In this level we learn the tactic `exact`, which solves a goal that is exactly one of the hypotheses.\nThe lemma is the same as in the previous level, but we will solve it in a different way.\n", "By doing a `rw` you will get the goal to look exactly like one of the hypotheses...\n", "Click here for a hint, in case you get stuck.", "variables {\u03a9 : Type} -- hide\n", "If A, B and C are points with A = B and B = C, then A = C.\n", "import tutorial_world.incidenceplane --hide\n", "open IncidencePlane --hide\n", "line_through_left : P \u2208 (line_through P Q)\n", "line_through_right : Q \u2208 (line_through P Q)\n", "We can apply a theorem that we have already proven by using `exact`\nand the appropriate hypotheses.\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "A point lies in the line through it.\n", "import tutorial_world.incidenceplane --hide\n", "open IncidencePlane --hide\n", "incidence : P \u2260 Q \u2192 P \u2208 \u2113 \u2192 Q \u2208 \u2113 \u2192 \u2113 = line_through P Q\n", "\n## Summary:\n\n`intro p` will turn a goal `\u22a2 P \u2192 Q` into a hypothesis `p : P`\nand goal `\u22a2 Q`. If `P` and `Q` are sets `intro p` means \"let $p$ be an arbitrary element of $P$\".\nIf `P` and `Q` are propositions then `intro p` says \"assume $P$ is true\". \n\n## Details\n\nIf your goal is a function or an implication `\u22a2 P \u2192 Q` then `intro`\nwill always make progress. `intro p` turns\n\n`\u22a2 P \u2192 Q`\n\ninto \n\n```\np : P\n\u22a2 Q\n```\n\nThe opposite tactic to intro is `revert`; given the situation\njust above, `revert p` turns the goal back into `\u22a2 P \u2192 Q`.\n\n**Variant:** Instead of calling `intro` multiple times, you can use\n`intros`. That is, `intros h\u2081 h\u2082` is equivalent to `intro h\u2081, intro h\u2082`.\n\n## Example\n\nIf your goal is an implication $P\\implies Q$ then Lean writes\nthis as `\u22a2 P \u2192 Q`, and `intro p,` can be thought of as meaning\n\"let $p$ be a proof of $P$\", or more informally \"let's assume that\n$P$ is true\". The goal changes to `\u22a2 Q` and the hypothesis `p : P`\nappears in the local context.\n\n", "This level introduces the `intros` tactic. This allows you to introduce\na new hypothesis in the context. You can learn more about it in the side bar.\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "variables {A B : \u03a9} {r s : Line \u03a9} -- hide\n", "If two lines contain two distinct points, then they are the same\n", "import tutorial_world.level06_intro --hide\n", "open IncidencePlane --hide\n", "\n## Summary:\n\nIf the goal is `P \u2227 Q` or `P \u2194 Q` then `split` will break it into two goals.\n\n## Details\n\nIf `P Q : Prop` and the goal is `\u22a2 P \u2227 Q`, then `split` will change it into\ntwo goals, namely `\u22a2 P` and `\u22a2 Q`. \n\nIf `P Q : Prop` and the goal is `\u22a2 P \u2194 Q`, then `split` will change it into\ntwo goals, namely `\u22a2 P \u2192 Q` and `\u22a2 Q \u2192 P`.  \n\n## Example:\n\nIf your local context (the top right window) looks like this\n```\nX : Type\nA B : set X\nx : X\n\u22a2 x \u2208 A \u2194 x \u2208 B\n```\n\nthen after\n\n`split,`\n\nit will look like this:\n\n```\n2 goals\nX : Type\nA B : set X\nx : X\n\u22a2 x \u2208 A \u2192 x \u2208 B\n\n\nX : Type\nA B : set X\nx : X\n\u22a2 x \u2208 B \u2192 x \u2208 A\n```\n", "In this level we will learn the `split` tactic. It breaks a goal `P \u2227 Q` into two goals (proving `P`, and then proving `Q`),\nand also breaks goals of the form `P \u2194 Q` into proving each of the implications separately.\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "If two lines contain two distinct points, then they are the same\n", "import tutorial_world.level07_split --hide\n", "open IncidencePlane --hide\n", "open set --hide\n", "\n## Summary\nThe tactic use specializes the goal with a particular case.\nFor example, if we want to prove the statement \"there exists a natural number which is odd\",\nwe will need to provide a concrete number like 3. \n", "Sometimes we will need to prove that there exists an object satisfying certain properties.\nThe goal will then look like \u22a2 \u2203 x, P x. In this case, the `use` tactic is useful. If we know\nthat an object `a` satisfies the  property `P`, then `use a` will transform the goal into \u22a2 P a.\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "Given a point, there is always a line containing it.\n", "import tutorial_world.level08_use --hide\n", "open IncidencePlane --hide\n", "\n## Summary\n`have h : P,` will create a new goal of creating a term of type `P`, and will add `h : P` to the hypotheses for the goal you were working on.\n\n## Details\nIf you want to name a term of some type (because you want it in your local context for some reason), and if you have the formula for the term, you can use have to give the term a name.\n\n## Example (have q := ... or have q : Q := ...)\nIf the local context contains\n\n```\nf : P \u2192 Q\np : P\n```\nthen the tactic `have q := f(p),` will add `q` to our local context, leaving it like this:\n\n```\nf : P \u2192 Q\np : P\nq : Q\n```\n\nIf you think about it, you don't ever really need `q`, because whenever you think you need it you coudl just use `f(p)` instead. But it's good that we can introduce convenient notation like this.\n\n## Example (have q : Q,)\nA variant of this tactic can be used where you just declare the type of the term you want to have, finish the tactic statement with a comma and no :=, and then Lean just adds it as a new goal. The number of goals goes up by one if you use `have` like this.\n\nFor example if the local context is\n\n```\nP Q R : Prop/Type,\nf : P \u2192 Q,\ng : Q \u2192 R,\np : P\n\u22a2 R\n```\nthen after `have q : Q,`, there will be the new goal\n\n```\nf : P \u2192 Q,\ng : Q \u2192 R,\np : P,\n\u22a2 Q\n```\nand your original goal will have `q : Q` added to the list of hypotheses.\n", "In this level we introduce the new tactic `have`. It is used to add a new hypothesis\nto the context (of course, you will have to prove it!). This is sometimes useful to\nstructure our proofs. In this particular level, it is convenient to prove first that\n`r = line_through B C`, then that `s = line_through B C` and that allows us to\nfinish the prove very easily.\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "If two lines share two distinct points then they are the same\n", "import tutorial_world.level09_have --hide\n", "open set IncidencePlane --hide\n", "\n## Summary:\n\n`cases` is a tactic which works on hypotheses.\nIf `h : P \u2227 Q` or `h : P \u2194 Q` is a hypothesis then `cases h with h1 h2` will remove `h`\nfrom the list of hypotheses and replace it with the \"ingredients\" of `h`,\ni.e. `h1 : P` and `h2 : Q`, or `h1 : P \u2192 Q` and `h2 : Q \u2192 P`. Also\nworks with `h : P \u2228 Q` and with `h : \u2203 x, P x`. \n\n## Details\n\nHow does one prove `P \u2227 Q`? The way to do it is to prove `P` and to\nprove `Q`. There are hence two ingredients which go into a proof of\n`P \u2227 Q`, and the `cases` tactic extracts them. \n\nMore precisely, if the local context contains\n```\nh : P \u2227 Q`\n```\n\nthen after the tactic `cases h with p q,` the local context will\nchange to\n```\np : P,\nq : Q\n```\nand `h` will disappear. \n\nSimilarly `h : P \u2194 Q` is proved by proving `P \u2192 Q` and `Q \u2192 P`,\nand `cases h with hpq hqp` will delete our assumption `h` and\nreplace it with\n```\nhpq : P \u2192 Q,\nhqp : Q \u2192 P\n```\n\nBe warned though -- `rw h` works with `h : P \u2194 Q` (`rw` works with\n`=` and `\u2194`), whereas you cannot rewrite with an implication.\n\n`cases` also works with hypotheses of the form `P \u2228 Q`. Here the situation\nis different however. \nTo prove `P \u2228 Q` you need to give either a proof of `P` *or* a proof\nof `Q`, so if `h : P \u2228 Q` then `cases h with p q` will change one goal\ninto two, one with `p : P` and the other with `q : Q`.\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "The next tactic we introduce is `cases`, and since it does many things\nwe will have a couple levels seeing when to apply it. This tactic works\nalways on hypotheses, and it transforms them in different ways. The first\ninstance that we learn arises when you have a hypothesis that says that `P`\nor `Q` holds. That is, you have `h : P \u2227 Q`. Then `cases h with h\u2081 h\u2082` will \nreplace `h` with two new hypotheses, namely `h\u2081 : P` and `h\u2082 : Q`.\n\nThis is done usually for aesthetic reasons, since `h.1` and `h.2` also serve\nas proofs of `P` and `Q`.\n", "The line \u2113 is the line through P and Q as long as P \u2260 Q and both P and Q are in \u2113\n", "import tutorial_world.level10_cases1_and --hide\n", "open set IncidencePlane --hide\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "Suppose now that your hypothesis says that `P`\n**or** `Q` holds. That is, you have `h : P \u2228 Q`. Then `cases h` will\ncreate two new goals, and in each of them it will\nreplace `h` with `h : P` in the first case, and with `h : Q` in the second.\n\n", "If X is any set in \u03a9 and either P or Q is in X, then X is not empty.\n", "import tutorial_world.level11_cases2_or --hide\n", "open set IncidencePlane --hide\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "Suppose now that your hypothesis says there is some element `x` satisfying a certain\nproperty `P`. That is, you have `h : \u2203 x, P x`. Then `cases h with x hx` will\nreplace `h` with `x : X` and `hx : P x`. That is, from the fact that you know that\nsome `x` exists, it will give you one such `x` with the property that it is supposed\nto satisfy.\n\n", "A line through 4 points given lines through two subsets of three\n", "import tutorial_world.level12_cases3_exists --hide\n", "open IncidencePlane --hide\n", "open set --hide\n", "## Summary\n`left` and `right` work on the goal, and they change\n`\u22a2 P \u2228 Q` to `\u22a2 P` and `\u22a2 Q` respectively.\n## Details\nThe tactics `left` and `right` work on a goal which is a type with\ntwo constructors, the classic example being `P \u2228 Q`. \nTo prove `P \u2228 Q` it suffices to either prove `P` or prove `Q`,\nand once you know which one you are going for you can change\nthe goal with `left` or `right` to the appropriate choice.\n", "We have seen how to prove a goal of the form `P \u2227 Q`, now you will learn how to prove\na goal of the form `P \u2228 Q`, which means that either `P` holds or `Q` holds.\nIn this case, you will have to decide whether you can prove `P` or `Q`. The `left` and `right`\ntactics will allow you to change the goal to \u22a2 P or \u22a2 Q accordingly.\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] -- hide\n", "Example of the usage of left and right\n", "import tutorial_world.level13_leftright --hide\n", "open IncidencePlane --hide\n", "\n## Summary\n\nIf `h : P \u2192 Q` is a hypothesis, and the goal is `\u22a2 Q` then\n`apply h` changes the goal to `\u22a2 P`. \n\n## Details\n\nIf you have a function `h : P \u2192 Q` and your goal is `\u22a2 Q`\nthen `apply h` changes the goal to `\u22a2 P`. The logic is\nsimple: if you are trying to create a term of type `Q`,\nbut `h` is a function which turns terms of type `P` into\nterms of type `Q`, then it will suffice to construct a\nterm of type `P`. A mathematician might say: \"we need\nto construct an element of $Q$, but we have a function $h:P\\to Q$\nso it suffices to construct an element of $P$\". Or alternatively\n\"we need to prove $Q$, but we have a proof $h$ that $P\\implies Q$\nso it suffices to prove $P$\".\n\n", "In this level we introduce the new tactic `apply`. Suppose that you have a theorem `h`\nthat states exactly that your goal is true, provided that some hypotheses are satisfied. Then\n`apply h` will change your goal into proving your new hypotheses.\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] -- hide\n", "variables {P Q : \u03a9} -- hide\n", "The line through two points is a symmetrical concept\n", "import tutorial_world.level14_apply --hide\n", "open IncidencePlane --hide\n", "\n## Summary\nThe `simp` tactic is a high-level tactic which tries to prove equalities using facts in its database.\n\n## Details\nThe `simp` tactic does basic automation. It uses lemmas already proved that have been tagged\nwith a special label, to simplify either a goal or a hypothesis.\n\n## Example:\nFor `S` a segment, we have a lemma\n`mem_pts : P \u2208 S \u2194 P = S.A \u2228 P = S.B \u2228 (S.A * P * S.B)`, and it is tagged as a simp lemma\nin this game. This means that the `simp` tactic will replace occurrences of `P \u2208 S` with\nthe right-hand side, which is more concrete.\n", "In this level we introduce a high level tactic called `simp`. This simplifies statements\nusing (some) lemmas already in our database. As a simple example, for `S` a segment we have a lemma\n`mem_pts : P \u2208 S \u2194 P = S.A \u2228 P = S.B \u2228 (S.A * P * S.B)`, and it is tagged as a simp lemma\nin this game. This means that the `simp` tactic will replace occurrences of `P \u2208 S` with\nthe right-hand side, which is more concrete. Try it below.\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "A point in between the endpoints of a segment is in the segment.\n", "import tutorial_world.level15_simp -- hide\n", "open IncidencePlane -- hide\n", "\n## Summary\n\nChanges the goal to `\u22a2 false`.\n\n## Details\n\nThis may seem hard to prove,\nbut it is useful when we have a contradiction in the hypotheses.\n\nFor example, if we have `h : \u00ac P` as a hypothesis and we apply `exfalso`\nwe can then `apply h` to transform the goal into `\u22a2 P`.\n", "In this level we introduce the new tactic `exfalso`. Look at what it does, it is a bit\nstrange at first. We will also need one of the axioms for our plane, the one that says that\nthe line through two points contains each of them. You can see the statement of this theorem\non the left sidebar.\n", "In Lean, the  negation `\u00ac P` of a statement is a shorthand for `P \u2192 false`. Therefore\nstart with `exfalso`, and remember that negation is the same as `\u2192 false`.\n", "Click here for a hint, in case you get stuck.", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "Prove that 2+2 is 5, using a false hypothesis.\n", "import tutorial_world.level16_exfalso --hide\n", "open IncidencePlane --hide\n", "\n## Summary\n\nGenerates two goals corresponding to a given statement being\ntrue or false\n\n## Details\n\nSuppose that we want to prove a statement `P x`, where `x`\nis some number. We may know how to prove it when `x \u2264 5`\nand also when `x > 5`, but using a different method.\nIn this situation, using `by_cases h : x \u2264 5,` will produce\ntwo new goals, the first one with `h : x \u2264 5` in the context\nand the second one with `h : \u00ac x \u2264 5`.\n", "Sometimes we need to split a proof into different cases,\nbecause the arguments depend on some condition. The `by_cases`\ntactic does precisely this.\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "Either a point is in a line or it is not.\n", "import tutorial_world.level17_by_cases --hide\n", "open set IncidencePlane --hide\n", "This is an extra level you can use for practice.\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "The only point on the segment A\u2b1dA is A itself.\n", "Incidence World", "import tutorial_world.level18_practice --hide\n", "open IncidencePlane --hide\n", "existence : \u2203 P Q R : \u03a9, P \u2260 Q \u2227 P \u2260 R \u2227 Q \u2260 R \u2227 R \u2209 (line_through P Q)\n", "Now that we have introduced the basic Lean tactics, \nlet's move on to proving our first theorems.\n\nThe goal of this world is to prove the existence of\ntriangles, but we will start showing that there is no line\nthat covers the whole plane. That is, every line misses\nat least one point.\n", "This is really a proof `by_cases`, and you will need to come up\nwith some candidate points...\n", "Click here for a hint, in case you get stuck.", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "Every line misses at least one point.\n", "import incidence_world.level01 --hide\n", "open IncidencePlane --hide\n", "The next lemma is not hard to prove, but it will be useful\nin the coming levels.\n", "Remember that `\u00ac P` is the same as `P \u2192 false`, so `intro` may\nget you going.\n", "Click here for a hint, in case you get stuck.", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "variables  {P Q: \u03a9} {r : Line \u03a9}  -- hide\n", "If a point P is in a line and a point Q is not, then they are different.\n", "import incidence_world.level02--hide\n", "open IncidencePlane --hide\n", "Using the lemma `point_in_line_not_point` that you proved in the previous\nlevel, we can prove a stronger version of the existence axiom. Remember that\nthis axiom says that there are three distinct non-collinear points. The\nresult in this level says that if we fix one point P, then we can find\ntwo other distinct points such that the three of them are non-collinear.\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "Given a point P, there exist two points Q and R, such that the three points are not collinear.\n", "import incidence_world.level03 --hide\n", "open IncidencePlane --hide\n", "Remember that a couple of levels ago we proved that a line could help\nus deciding that two points were different. Now we will see that\na point can help us deciding that two lines are different.\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "variables {P : \u03a9} {r s : Line \u03a9} --hide\n", "If two lines `r` and `s` do not share a point, then they are not equal.\n", "import incidence_world.level04 --hide\n", "open IncidencePlane --hide\n", "Using the lemma we have just proved, we can now prove that\na single point never determines a line. That is, that there are\nalways at least two lines passing through any given point.\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "There are at least two different lines passing through a given point.\n", "import incidence_world.level05 --hide\n", "open IncidencePlane --hide\n", "We end this world by proving the existence of triangles\nusing only incidence axioms.\n", "variables {\u03a9 : Type} [IncidencePlane \u03a9] --hide\n", "There exist three lines that do not have a point in common.\n"]]}